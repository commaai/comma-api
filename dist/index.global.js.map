{"version":3,"sources":["../src/account.ts","../src/config.ts","../src/instance.ts","../src/request.ts","../src/athena.ts","../src/auth.ts","../src/billing.ts","../src/clips.ts","../src/devices.ts","../src/derived.ts","../src/drives.ts","../src/raw.ts","../src/navigation.ts","../src/video.ts"],"sourcesContent":["import request from './request'\n\nexport function getProfile(dongleId = 'me') {\n  return request.get(`v1/${dongleId}/`)\n}\n","interface CommaApiConfig {\n  COMMA_API_URL: string\n  ATHENA_API_URL: string\n  BILLING_API_URL: string\n}\n\ndeclare global {\n  interface Window {\n    Comma: CommaApiConfig\n  }\n}\n\nexport default {\n  COMMA_API_URL: window?.Comma.COMMA_API_URL || 'https://api.comma.ai/',\n  ATHENA_API_URL: window?.Comma.ATHENA_API_URL || 'https://athena.comma.ai/',\n  BILLING_API_URL: window?.Comma.BILLING_API_URL || 'https://billing.comma.ai/',\n}\n","export class RequestError extends Error {\n  resp: Response\n\n  constructor(resp, ...params) {\n    super(...params)\n    this.resp = resp\n  }\n}\n\nexport default class ConfigRequest {\n  baseUrl: string\n  defaultHeaders: Record<string, string>\n\n  constructor(baseUrl) {\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n    }\n    this.baseUrl = baseUrl + (!baseUrl.endsWith('/') ? '/' : '')\n  }\n\n  configure(accessToken: string): void {\n    this.defaultHeaders['Authorization'] = `JWT ${accessToken}`\n  }\n\n  async request(method: string, endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    const headers = { ...this.defaultHeaders }\n    if (!dataJson) {\n      headers['Content-Type'] = 'application/x-www-form-urlencoded'\n    }\n\n    let requestUrl = this.baseUrl + endpoint\n    let body\n    if (params && Object.keys(params).length !== 0) {\n      if (method === 'GET' || method === 'HEAD') {\n        requestUrl += `?${new URLSearchParams(params)}`\n      } else if (dataJson) {\n        body = JSON.stringify(params)\n      } else {\n        body = new URLSearchParams(params).toString()\n      }\n    }\n\n    const resp = await fetch(requestUrl, { method, headers, body })\n    if (!resp.ok) {\n      const error = await resp.text()\n      throw new RequestError(resp, `${resp.status}: ${error}`)\n    }\n    if (!respJson) {\n      return resp\n    }\n    return resp.json()\n  }\n\n  async get(endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    return this.request('GET', endpoint, params, dataJson, respJson)\n  }\n\n  async head(endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    return this.request('HEAD', endpoint, params, dataJson, respJson)\n  }\n\n  async post(endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    return this.request('POST', endpoint, params, dataJson, respJson)\n  }\n\n  async postForm(endpoint: string, params?: Record<string, any>) {\n    return this.post(endpoint, params, false)\n  }\n\n  async put(endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    return this.request('PUT', endpoint, params, dataJson, respJson)\n  }\n\n  async delete(endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    return this.request('DELETE', endpoint, params, dataJson, respJson)\n  }\n\n  async patch(endpoint: string, params?: Record<string, any>, dataJson = true, respJson = true) {\n    return this.request('PATCH', endpoint, params, dataJson, respJson)\n  }\n}\n","import Config from './config';\nimport ConfigRequest from './instance';\n\nexport default new ConfigRequest(Config.COMMA_API_URL);\n","import Config from './config'\nimport ConfigRequest from './instance'\n\nconst request = new ConfigRequest(Config.ATHENA_API_URL)\n\nexport function configure(accessToken: string) {\n  request.configure(accessToken)\n}\n\nexport async function postJsonRpcPayload(dongleId: string, payload) {\n  return request.post(dongleId, payload)\n}\n","import request from './request'\n\nexport async function refreshAccessToken(code: string, provider: string): Promise<string> {\n  const resp = await request.postForm('v2/auth/', { code, provider })\n\n  if (resp.access_token != null) {\n    request.configure(resp.access_token)\n    return resp.access_token\n  } if (resp.response !== undefined) {\n    throw new Error(`Could not exchange oauth code for access token: response ${resp.response}`)\n  } else if (resp.error !== undefined) {\n    throw new Error(`Could not exchange oauth code for access token: error ${resp.error}`)\n  } else {\n    throw new Error(`Could not exchange oauth code for access token: ${resp}`)\n  }\n}\n","import Config from './config'\nimport ConfigRequest from './instance'\n\nconst request = new ConfigRequest(Config.BILLING_API_URL)\n\nexport function configure(accessToken: string) {\n  request.configure(accessToken)\n}\n\nexport async function getSubscription(dongle_id: string) {\n  return request.get('v1/prime/subscription', { dongle_id })\n}\n\nexport async function getSubscribeInfo(dongle_id: string) {\n  return request.get('v1/prime/subscribe_info', { dongle_id })\n}\n\nexport async function cancelPrime(dongle_id: string) {\n  return request.post('v1/prime/cancel', { dongle_id })\n}\n\nexport async function getSimValid(dongle_id: string, sim_id: string) {\n  return request.get('v1/prime/sim_valid', { dongle_id, sim_id })\n}\n\nexport async function getStripeCheckout(dongle_id: string, sim_id: string, plan: string) {\n  return request.post('v1/prime/stripe_checkout', { dongle_id, sim_id, plan })\n}\n\nexport async function getStripePortal(dongle_id: string) {\n  return request.get('v1/prime/stripe_portal', { dongle_id })\n}\n\nexport async function getStripeSession(dongle_id: string, session_id: string) {\n  return request.get('v1/prime/stripe_session', { dongle_id, session_id })\n}\n","import request from './request'\n\nexport async function clipsCreate(route: string, title: string, start_time: number, end_time: number, video_type: string, is_public: boolean) {\n  return request.post('v1/clips/create', {\n    route, title, start_time, end_time, video_type, is_public,\n  })\n}\n\nexport async function clipsList(dongle_id: string) {\n  return request.get('v1/clips/list', { dongle_id })\n}\n\nexport async function clipsDetails(dongle_id: string, clip_id: string) {\n  return request.get('v1/clips/details', { dongle_id, clip_id })\n}\n\nexport async function clipsUpdate(dongle_id: string, clip_id: string, is_public: boolean) {\n  return request.patch('v1/clips/update', { dongle_id, clip_id, is_public })\n}\n\nexport async function clipsDelete(dongle_id: string, clip_id: string) {\n  return request.delete('v1/clips/update', { dongle_id, clip_id })\n}\n","import request from './request';\n\n\nexport function listDevices() {\n  return request.get('v1/me/devices/');\n}\n\nexport function setDeviceAlias(dongleId: string, alias: string) {\n  return request.patch(`v1/devices/${dongleId}/`, { alias });\n}\n\nexport function grantDeviceReadPermission(dongleId: string, email: string) {\n  return request.post(`v1/devices/${dongleId}/add_user`, { email });\n}\n\nexport function removeDeviceReadPermission(dongleId: string, email: string) {\n  return request.post(`v1/devices/${dongleId}/del_user`, { email });\n}\n\nexport async function fetchLocation(dongleId: string) {\n  const locationEndpoint = `v1/devices/${dongleId}/location`;\n  const location = await request.get(locationEndpoint);\n  if (location !== undefined && location.error === undefined) {\n    return location;\n  }\n  throw Error(`Could not fetch device location: ${JSON.stringify(location)}`);\n}\n\nexport function fetchDevice(dongleId: string) {\n  const deviceEndpoint = `v1.1/devices/${dongleId}/`;\n  return request.get(deviceEndpoint);\n}\n\nexport function pilotPair(pair_token: string) {\n  return request.postForm('v2/pilotpair/', { pair_token });\n}\n\nexport function fetchDeviceStats(dongleId: string) {\n  return request.get(`v1.1/devices/${dongleId}/stats`);\n}\n\nexport function unpair(dongleId: string) {\n  return request.post(`v1/devices/${dongleId}/unpair`);\n}\n\nexport function fetchDeviceOwner(dongleId: string) {\n  return request.get(`v1/devices/${dongleId}/owner`);\n}\n\nexport function getAthenaQueue(dongleId: string) {\n  return request.get(`v1/devices/${dongleId}/athena_offline_queue`);\n}\n","import ConfigRequest from './instance';\n\n\nexport default function routeApi(routeSigUrl: string) {\n  const request = new ConfigRequest(routeSigUrl);\n\n  return {\n    getCoords: async (cacheKey = 0) => request.get(`route.coords?s=${cacheKey}`),\n    getJpegUrl: (routeOffsetSeconds: number) => `${routeSigUrl}/sec/${routeOffsetSeconds.toString()}.jpg`,\n  };\n}\n","import request from './request'\n\nconst SEGMENT_LENGTH = 1000 * 60\n\nexport function getSegmentMetadata(start: number, end: number, dongleId: string) {\n  return request.get(`v1/devices/${dongleId}/segments`, {\n    from: start,\n    to: end,\n  })\n}\n\nexport function getRoutesSegments(dongleId: string, start: number, end: number) {\n  return request.get(`v1/devices/${dongleId}/routes_segments`, { start, end })\n}\n\nexport function getRouteInfo(routeName: string) {\n  return request.get(`v1/route/${routeName}/`)\n}\n\nexport function setRoutePublic(routeName: string, is_public: boolean) {\n  return request.patch(`v1/route/${routeName}/`, { is_public })\n}\n\nexport function setRoutePreserved(routeName: string, preserved: boolean) {\n  return request.request(preserved ? 'POST' : 'DELETE', `v1/route/${routeName}/preserve`)\n}\n\nexport function getPreservedRoutes(dongleId: string) {\n  return request.get(`v1/devices/${dongleId}/routes/preserved`)\n}\n\nexport function getShareSignature(routeName: string) {\n  return request.get(`v1/route/${routeName}/share_signature`)\n}\n\nexport function getRouteSegments(routeName: string) {\n  return request.get(`v1/route/${routeName}/segments`)\n}\n\nexport function listRoutes(dongleId: string, limit: number, createdAfter?: number) {\n  return request.get(`v1/devices/${dongleId}/routes`, { limit, createdAfter })\n}\n\nfunction parseSegmentMetadata(start: number, end: number, segments) {\n  const routeStartTimes = {};\n\n  return segments.map((s) => {\n    const segment = {\n      ...s,\n      duration: Math.round(s.end_time_utc_millis - s.start_time_utc_millis),\n      offset: Math.round(s.start_time_utc_millis) - start,\n    };\n\n    if (!routeStartTimes[s.canonical_route_name]) {\n      segment.segment = Number(s.canonical_name.split('--')[2]);\n      routeStartTimes[s.canonical_route_name] = segment.offset - (SEGMENT_LENGTH * segment.segment);\n    }\n    segment.routeOffset = routeStartTimes[s.canonical_route_name];\n\n    return segment;\n  });\n}\n\n// TODO: understand this and write tests\nfunction segmentsFromMetadata(segmentsData) {\n  function finishSegment(segment) {\n    if (!segment.hasVideo) {\n      return;\n    }\n\n    const { videoAvailableBetweenOffsets } = segment;\n    let lastVideoRange = videoAvailableBetweenOffsets[videoAvailableBetweenOffsets.length - 1];\n    if (!lastVideoRange) {\n      lastVideoRange = [segment.offset, segment.offset + segment.duration];\n    }\n\n    // TODO: refactor\n    // eslint-disable-next-line no-param-reassign\n    segment.videoAvailableBetweenOffsets = [\n      ...videoAvailableBetweenOffsets.slice(0, videoAvailableBetweenOffsets.length - 1),\n      [lastVideoRange[0], segment.offset + segment.duration],\n    ];\n  }\n\n  let segment = null;\n  let videoStartOffset = null;\n  const segments = [];\n  segmentsData.forEach((s) => {\n    if (!s.url) {\n      return;\n    }\n    if (!(s.proc_log === 40 || s.proc_qlog === 40)) {\n      return;\n    }\n    const segmentHasDriverCamera = (s.proc_dcamera >= 0);\n    const segmentHasDriverCameraStream = (s.proc_dcamera === 40);\n    const segmentHasVideo = (s.proc_camera === 40);\n    if (segmentHasVideo && videoStartOffset === null) {\n      videoStartOffset = s.offset;\n    }\n\n    if (!segment || segment.route !== s.canonical_route_name) {\n      if (segment) {\n        finishSegment(segment);\n      }\n      let { url } = s;\n      const parts = url.split('/');\n\n      if (Number.isFinite(Number(parts.pop()))) {\n        // url has a number at the end\n        url = parts.join('/');\n      }\n      segment = {\n        dongleId: s.dongle_id,\n        offset: s.offset - (s.segment * SEGMENT_LENGTH),\n        route: s.canonical_route_name,\n        startTime: s.start_time_utc_millis,\n        startCoord: [s.start_lng, s.start_lat],\n        duration: 0,\n        segments: 0,\n        url: url.replace('chffrprivate.blob.core.windows.net', 'chffrprivate.azureedge.net'),\n        events: [],\n        videoAvailableBetweenOffsets: [],\n        hasVideo: segmentHasVideo,\n        deviceType: s.devicetype,\n        hpgps: s.hpgps,\n        hasDriverCamera: segmentHasDriverCamera,\n        hasDriverCameraStream: segmentHasDriverCameraStream,\n        locStart: '',\n        locEnd: '',\n        distanceMiles: 0.0,\n        cameraStreamSegCount: 0,\n        driverCameraStreamSegCount: 0,\n      };\n      segments.push(segment);\n    }\n    if (!segmentHasVideo && videoStartOffset !== null) {\n      segment.videoAvailableBetweenOffsets.push([videoStartOffset, s.offset]);\n      videoStartOffset = null;\n    }\n    segment.hasVideo = (segment.hasVideo || segmentHasVideo);\n    segment.hasDriverCamera = (segment.hasDriverCamera || segmentHasDriverCamera);\n    segment.hasDriverCameraStream = (segment.hasDriverCameraStream || segmentHasDriverCameraStream);\n    segment.hpgps = (segment.hpgps || s.hpgps);\n    segment.duration = (s.offset - segment.offset) + s.duration;\n    segment.segments = Math.max(segment.segments, Number(s.canonical_name.split('--').pop()) + 1);\n    segment.events = segment.events.concat(s.events);\n    segment.endCoord = [s.end_lng, s.end_lat];\n    segment.distanceMiles += s.length;\n    segment.cameraStreamSegCount += segmentHasVideo;\n    segment.driverCameraStreamSegCount += segmentHasDriverCameraStream;\n  });\n\n  if (segment) {\n    finishSegment(segment);\n  }\n\n  return segments;\n}\n\nexport async function fetchRoutes(dongleId: string, start: number, end: number) {\n  let segments = await getSegmentMetadata(start, end, dongleId);\n  segments = parseSegmentMetadata(start, end, segments);\n  return segmentsFromMetadata(segments).reverse();\n}\n","import request from './request'\n\n// TODO: investigate whether to use IndexedDB or localStorage\nconst urlStore: Record<string, any> = {}\n\nasync function getCached(endpoint: string, params?: Record<string, any>, nocache = false) {\n  let url = endpoint\n  if (params !== undefined) {\n    url += `?${new URLSearchParams(params)}`\n  }\n\n  // don't bother bouncing because the URLs themselves expire\n  // our expiry time is from initial fetch time, not most recent access\n  if (urlStore[url] && !nocache) {\n    return urlStore[url]\n  }\n\n  urlStore[url] = await request.get(url)\n\n  setTimeout(() => {\n    delete urlStore[url]\n  }, 1000 * 60 * 45) // expires in 1h, lets reset in 45m\n\n  return urlStore[url]\n}\n\nexport function getRouteFiles(routeName: string, nocache = false, params = undefined) {\n  return getCached(`v1/route/${routeName}/files`, params, nocache)\n}\n\nexport function getLogUrls(routeName: string, params) {\n  return getCached(`v1/route/${routeName}/log_urls`, params)\n}\n\nexport function getUploadUrl(dongleId: string, path: string, expiry_days?: number) {\n  return getCached(`v1.4/${dongleId}/upload_url/`, { path, expiry_days })\n}\n\nexport async function getUploadUrls(dongleId: string, paths: string[], expiry_days?: number) {\n  return request.post(`v1/${dongleId}/upload_urls/`, { paths, expiry_days })\n}\n","import request from './request'\n\nexport function setDestination(dongleId: string, latitude, longitude, place_name: string, place_details: string) {\n  return request.post(`v1/navigation/${dongleId}/set_destination`, {\n    latitude,\n    longitude,\n    place_name,\n    place_details,\n  })\n}\n\nexport function getLocationsData(dongleId: string) {\n  return request.get(`v1/navigation/${dongleId}/locations`)\n}\n\nexport function putLocationSave(\n  dongleId: string,\n  latitude: number,\n  longitude: number,\n  place_name: string,\n  place_details: string,\n  save_type?: 'favorite' | 'recent',\n  label?: string,\n) {\n  return request.put(`v1/navigation/${dongleId}/locations`, {\n    latitude,\n    longitude,\n    place_name,\n    place_details,\n    save_type,\n    label,\n  })\n}\n\nexport function patchLocationSave(dongleId: string, navLocationId: number, saveType: 'favorite' | 'recent', label?: string) {\n  return request.patch(`v1/navigation/${dongleId}/locations`, {\n    id: navLocationId,\n    save_type: saveType,\n    label,\n  })\n}\n\nexport function deleteLocationSave(dongleId: string, navLocationId: number) {\n  return request.delete(`v1/navigation/${dongleId}/locations`, { id: navLocationId })\n}\n\nexport function getLocationsNext(dongleId: string) {\n  return request.get(`v1/navigation/${dongleId}/next`)\n}\n","import Config from './config'\nimport ConfigRequest from './instance'\n\nconst request = new ConfigRequest(Config.COMMA_API_URL)\n\nexport function getQcameraStreamUrl(routeStr: string, exp: string, sig: string) {\n  return `${request.baseUrl}v1/route/${routeStr}/qcamera.m3u8?${new URLSearchParams({ exp, sig })}`\n}\n"],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;;;ACYA,MAAO,iBAAQ;AAAA,IACb,gBAAe,iCAAQ,MAAM,kBAAiB;AAAA,IAC9C,iBAAgB,iCAAQ,MAAM,mBAAkB;AAAA,IAChD,kBAAiB,iCAAQ,MAAM,oBAAmB;AAAA,EACpD;;;AChBO,MAAM,eAAN,cAA2B,MAAM;AAAA,IAGtC,YAAY,SAAS,QAAQ;AAC3B,YAAM,GAAG,MAAM;AACf,WAAK,OAAO;AAAA,IACd;AAAA,EACF;AAEA,MAAqB,gBAArB,MAAmC;AAAA,IAIjC,YAAY,SAAS;AACnB,WAAK,iBAAiB;AAAA,QACpB,gBAAgB;AAAA,MAClB;AACA,WAAK,UAAU,WAAW,CAAC,QAAQ,SAAS,GAAG,IAAI,MAAM;AAAA,IAC3D;AAAA,IAEA,UAAU,aAA2B;AACnC,WAAK,eAAe,eAAe,IAAI,OAAO;AAAA,IAChD;AAAA,IAEA,MAAM,QAAQ,QAAgB,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC9G,YAAM,UAAU,EAAE,GAAG,KAAK,eAAe;AACzC,UAAI,CAAC,UAAU;AACb,gBAAQ,cAAc,IAAI;AAAA,MAC5B;AAEA,UAAI,aAAa,KAAK,UAAU;AAChC,UAAI;AACJ,UAAI,UAAU,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AAC9C,YAAI,WAAW,SAAS,WAAW,QAAQ;AACzC,wBAAc,IAAI,IAAI,gBAAgB,MAAM;AAAA,QAC9C,WAAW,UAAU;AACnB,iBAAO,KAAK,UAAU,MAAM;AAAA,QAC9B,OAAO;AACL,iBAAO,IAAI,gBAAgB,MAAM,EAAE,SAAS;AAAA,QAC9C;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,MAAM,YAAY,EAAE,QAAQ,SAAS,KAAK,CAAC;AAC9D,UAAI,CAAC,KAAK,IAAI;AACZ,cAAM,QAAQ,MAAM,KAAK,KAAK;AAC9B,cAAM,IAAI,aAAa,MAAM,GAAG,KAAK,WAAW,OAAO;AAAA,MACzD;AACA,UAAI,CAAC,UAAU;AACb,eAAO;AAAA,MACT;AACA,aAAO,KAAK,KAAK;AAAA,IACnB;AAAA,IAEA,MAAM,IAAI,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC1F,aAAO,KAAK,QAAQ,OAAO,UAAU,QAAQ,UAAU,QAAQ;AAAA,IACjE;AAAA,IAEA,MAAM,KAAK,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC3F,aAAO,KAAK,QAAQ,QAAQ,UAAU,QAAQ,UAAU,QAAQ;AAAA,IAClE;AAAA,IAEA,MAAM,KAAK,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC3F,aAAO,KAAK,QAAQ,QAAQ,UAAU,QAAQ,UAAU,QAAQ;AAAA,IAClE;AAAA,IAEA,MAAM,SAAS,UAAkB,QAA8B;AAC7D,aAAO,KAAK,KAAK,UAAU,QAAQ,KAAK;AAAA,IAC1C;AAAA,IAEA,MAAM,IAAI,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC1F,aAAO,KAAK,QAAQ,OAAO,UAAU,QAAQ,UAAU,QAAQ;AAAA,IACjE;AAAA,IAEA,MAAM,OAAO,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC7F,aAAO,KAAK,QAAQ,UAAU,UAAU,QAAQ,UAAU,QAAQ;AAAA,IACpE;AAAA,IAEA,MAAM,MAAM,UAAkB,QAA8B,WAAW,MAAM,WAAW,MAAM;AAC5F,aAAO,KAAK,QAAQ,SAAS,UAAU,QAAQ,UAAU,QAAQ;AAAA,IACnE;AAAA,EACF;;;AC7EA,MAAO,kBAAQ,IAAI,cAAc,eAAO,aAAa;;;AHD9C,WAAS,WAAW,WAAW,MAAM;AAC1C,WAAO,gBAAQ,IAAI,MAAM,WAAW;AAAA,EACtC;;;AIJA;AAAA;AAAA;AAAA;AAAA;AAGA,MAAM,UAAU,IAAI,cAAc,eAAO,cAAc;AAEhD,WAAS,UAAU,aAAqB;AAC7C,YAAQ,UAAU,WAAW;AAAA,EAC/B;AAEA,iBAAsB,mBAAmB,UAAkB,SAAS;AAClE,WAAO,QAAQ,KAAK,UAAU,OAAO;AAAA,EACvC;;;ACXA;AAAA;AAAA;AAAA;AAEA,iBAAsB,mBAAmB,MAAc,UAAmC;AACxF,UAAM,OAAO,MAAM,gBAAQ,SAAS,YAAY,EAAE,MAAM,SAAS,CAAC;AAElE,QAAI,KAAK,gBAAgB,MAAM;AAC7B,sBAAQ,UAAU,KAAK,YAAY;AACnC,aAAO,KAAK;AAAA,IACd;AAAE,QAAI,KAAK,aAAa,QAAW;AACjC,YAAM,IAAI,MAAM,4DAA4D,KAAK,UAAU;AAAA,IAC7F,WAAW,KAAK,UAAU,QAAW;AACnC,YAAM,IAAI,MAAM,yDAAyD,KAAK,OAAO;AAAA,IACvF,OAAO;AACL,YAAM,IAAI,MAAM,mDAAmD,MAAM;AAAA,IAC3E;AAAA,EACF;;;ACfA;AAAA;AAAA;AAAA,qBAAAA;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,MAAMC,WAAU,IAAI,cAAc,eAAO,eAAe;AAEjD,WAASC,WAAU,aAAqB;AAC7C,IAAAD,SAAQ,UAAU,WAAW;AAAA,EAC/B;AAEA,iBAAsB,gBAAgB,WAAmB;AACvD,WAAOA,SAAQ,IAAI,yBAAyB,EAAE,UAAU,CAAC;AAAA,EAC3D;AAEA,iBAAsB,iBAAiB,WAAmB;AACxD,WAAOA,SAAQ,IAAI,2BAA2B,EAAE,UAAU,CAAC;AAAA,EAC7D;AAEA,iBAAsB,YAAY,WAAmB;AACnD,WAAOA,SAAQ,KAAK,mBAAmB,EAAE,UAAU,CAAC;AAAA,EACtD;AAEA,iBAAsB,YAAY,WAAmB,QAAgB;AACnE,WAAOA,SAAQ,IAAI,sBAAsB,EAAE,WAAW,OAAO,CAAC;AAAA,EAChE;AAEA,iBAAsB,kBAAkB,WAAmB,QAAgB,MAAc;AACvF,WAAOA,SAAQ,KAAK,4BAA4B,EAAE,WAAW,QAAQ,KAAK,CAAC;AAAA,EAC7E;AAEA,iBAAsB,gBAAgB,WAAmB;AACvD,WAAOA,SAAQ,IAAI,0BAA0B,EAAE,UAAU,CAAC;AAAA,EAC5D;AAEA,iBAAsB,iBAAiB,WAAmB,YAAoB;AAC5E,WAAOA,SAAQ,IAAI,2BAA2B,EAAE,WAAW,WAAW,CAAC;AAAA,EACzE;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,iBAAsB,YAAY,OAAe,OAAe,YAAoB,UAAkB,YAAoB,WAAoB;AAC5I,WAAO,gBAAQ,KAAK,mBAAmB;AAAA,MACrC;AAAA,MAAO;AAAA,MAAO;AAAA,MAAY;AAAA,MAAU;AAAA,MAAY;AAAA,IAClD,CAAC;AAAA,EACH;AAEA,iBAAsB,UAAU,WAAmB;AACjD,WAAO,gBAAQ,IAAI,iBAAiB,EAAE,UAAU,CAAC;AAAA,EACnD;AAEA,iBAAsB,aAAa,WAAmB,SAAiB;AACrE,WAAO,gBAAQ,IAAI,oBAAoB,EAAE,WAAW,QAAQ,CAAC;AAAA,EAC/D;AAEA,iBAAsB,YAAY,WAAmB,SAAiB,WAAoB;AACxF,WAAO,gBAAQ,MAAM,mBAAmB,EAAE,WAAW,SAAS,UAAU,CAAC;AAAA,EAC3E;AAEA,iBAAsB,YAAY,WAAmB,SAAiB;AACpE,WAAO,gBAAQ,OAAO,mBAAmB,EAAE,WAAW,QAAQ,CAAC;AAAA,EACjE;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGO,WAAS,cAAc;AAC5B,WAAO,gBAAQ,IAAI,gBAAgB;AAAA,EACrC;AAEO,WAAS,eAAe,UAAkB,OAAe;AAC9D,WAAO,gBAAQ,MAAM,cAAc,aAAa,EAAE,MAAM,CAAC;AAAA,EAC3D;AAEO,WAAS,0BAA0B,UAAkB,OAAe;AACzE,WAAO,gBAAQ,KAAK,cAAc,qBAAqB,EAAE,MAAM,CAAC;AAAA,EAClE;AAEO,WAAS,2BAA2B,UAAkB,OAAe;AAC1E,WAAO,gBAAQ,KAAK,cAAc,qBAAqB,EAAE,MAAM,CAAC;AAAA,EAClE;AAEA,iBAAsB,cAAc,UAAkB;AACpD,UAAM,mBAAmB,cAAc;AACvC,UAAM,WAAW,MAAM,gBAAQ,IAAI,gBAAgB;AACnD,QAAI,aAAa,UAAa,SAAS,UAAU,QAAW;AAC1D,aAAO;AAAA,IACT;AACA,UAAM,MAAM,oCAAoC,KAAK,UAAU,QAAQ,GAAG;AAAA,EAC5E;AAEO,WAAS,YAAY,UAAkB;AAC5C,UAAM,iBAAiB,gBAAgB;AACvC,WAAO,gBAAQ,IAAI,cAAc;AAAA,EACnC;AAEO,WAAS,UAAU,YAAoB;AAC5C,WAAO,gBAAQ,SAAS,iBAAiB,EAAE,WAAW,CAAC;AAAA,EACzD;AAEO,WAAS,iBAAiB,UAAkB;AACjD,WAAO,gBAAQ,IAAI,gBAAgB,gBAAgB;AAAA,EACrD;AAEO,WAAS,OAAO,UAAkB;AACvC,WAAO,gBAAQ,KAAK,cAAc,iBAAiB;AAAA,EACrD;AAEO,WAAS,iBAAiB,UAAkB;AACjD,WAAO,gBAAQ,IAAI,cAAc,gBAAgB;AAAA,EACnD;AAEO,WAAS,eAAe,UAAkB;AAC/C,WAAO,gBAAQ,IAAI,cAAc,+BAA+B;AAAA,EAClE;;;AChDe,WAAR,SAA0B,aAAqB;AACpD,UAAME,WAAU,IAAI,cAAc,WAAW;AAE7C,WAAO;AAAA,MACL,WAAW,OAAO,WAAW,MAAMA,SAAQ,IAAI,kBAAkB,UAAU;AAAA,MAC3E,YAAY,CAAC,uBAA+B,GAAG,mBAAmB,mBAAmB,SAAS;AAAA,IAChG;AAAA,EACF;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,MAAM,iBAAiB,MAAO;AAEvB,WAAS,mBAAmB,OAAe,KAAa,UAAkB;AAC/E,WAAO,gBAAQ,IAAI,cAAc,qBAAqB;AAAA,MACpD,MAAM;AAAA,MACN,IAAI;AAAA,IACN,CAAC;AAAA,EACH;AAEO,WAAS,kBAAkB,UAAkB,OAAe,KAAa;AAC9E,WAAO,gBAAQ,IAAI,cAAc,4BAA4B,EAAE,OAAO,IAAI,CAAC;AAAA,EAC7E;AAEO,WAAS,aAAa,WAAmB;AAC9C,WAAO,gBAAQ,IAAI,YAAY,YAAY;AAAA,EAC7C;AAEO,WAAS,eAAe,WAAmB,WAAoB;AACpE,WAAO,gBAAQ,MAAM,YAAY,cAAc,EAAE,UAAU,CAAC;AAAA,EAC9D;AAEO,WAAS,kBAAkB,WAAmB,WAAoB;AACvE,WAAO,gBAAQ,QAAQ,YAAY,SAAS,UAAU,YAAY,oBAAoB;AAAA,EACxF;AAEO,WAAS,mBAAmB,UAAkB;AACnD,WAAO,gBAAQ,IAAI,cAAc,2BAA2B;AAAA,EAC9D;AAEO,WAAS,kBAAkB,WAAmB;AACnD,WAAO,gBAAQ,IAAI,YAAY,2BAA2B;AAAA,EAC5D;AAEO,WAAS,iBAAiB,WAAmB;AAClD,WAAO,gBAAQ,IAAI,YAAY,oBAAoB;AAAA,EACrD;AAEO,WAAS,WAAW,UAAkB,OAAe,cAAuB;AACjF,WAAO,gBAAQ,IAAI,cAAc,mBAAmB,EAAE,OAAO,aAAa,CAAC;AAAA,EAC7E;AAEA,WAAS,qBAAqB,OAAe,KAAa,UAAU;AAClE,UAAM,kBAAkB,CAAC;AAEzB,WAAO,SAAS,IAAI,CAAC,MAAM;AACzB,YAAM,UAAU;AAAA,QACd,GAAG;AAAA,QACH,UAAU,KAAK,MAAM,EAAE,sBAAsB,EAAE,qBAAqB;AAAA,QACpE,QAAQ,KAAK,MAAM,EAAE,qBAAqB,IAAI;AAAA,MAChD;AAEA,UAAI,CAAC,gBAAgB,EAAE,oBAAoB,GAAG;AAC5C,gBAAQ,UAAU,OAAO,EAAE,eAAe,MAAM,IAAI,EAAE,CAAC,CAAC;AACxD,wBAAgB,EAAE,oBAAoB,IAAI,QAAQ,SAAU,iBAAiB,QAAQ;AAAA,MACvF;AACA,cAAQ,cAAc,gBAAgB,EAAE,oBAAoB;AAE5D,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAGA,WAAS,qBAAqB,cAAc;AAC1C,aAAS,cAAcC,UAAS;AAC9B,UAAI,CAACA,SAAQ,UAAU;AACrB;AAAA,MACF;AAEA,YAAM,EAAE,6BAA6B,IAAIA;AACzC,UAAI,iBAAiB,6BAA6B,6BAA6B,SAAS,CAAC;AACzF,UAAI,CAAC,gBAAgB;AACnB,yBAAiB,CAACA,SAAQ,QAAQA,SAAQ,SAASA,SAAQ,QAAQ;AAAA,MACrE;AAIA,MAAAA,SAAQ,+BAA+B;AAAA,QACrC,GAAG,6BAA6B,MAAM,GAAG,6BAA6B,SAAS,CAAC;AAAA,QAChF,CAAC,eAAe,CAAC,GAAGA,SAAQ,SAASA,SAAQ,QAAQ;AAAA,MACvD;AAAA,IACF;AAEA,QAAI,UAAU;AACd,QAAI,mBAAmB;AACvB,UAAM,WAAW,CAAC;AAClB,iBAAa,QAAQ,CAAC,MAAM;AAC1B,UAAI,CAAC,EAAE,KAAK;AACV;AAAA,MACF;AACA,UAAI,EAAE,EAAE,aAAa,MAAM,EAAE,cAAc,KAAK;AAC9C;AAAA,MACF;AACA,YAAM,yBAA0B,EAAE,gBAAgB;AAClD,YAAM,+BAAgC,EAAE,iBAAiB;AACzD,YAAM,kBAAmB,EAAE,gBAAgB;AAC3C,UAAI,mBAAmB,qBAAqB,MAAM;AAChD,2BAAmB,EAAE;AAAA,MACvB;AAEA,UAAI,CAAC,WAAW,QAAQ,UAAU,EAAE,sBAAsB;AACxD,YAAI,SAAS;AACX,wBAAc,OAAO;AAAA,QACvB;AACA,YAAI,EAAE,IAAI,IAAI;AACd,cAAM,QAAQ,IAAI,MAAM,GAAG;AAE3B,YAAI,OAAO,SAAS,OAAO,MAAM,IAAI,CAAC,CAAC,GAAG;AAExC,gBAAM,MAAM,KAAK,GAAG;AAAA,QACtB;AACA,kBAAU;AAAA,UACR,UAAU,EAAE;AAAA,UACZ,QAAQ,EAAE,SAAU,EAAE,UAAU;AAAA,UAChC,OAAO,EAAE;AAAA,UACT,WAAW,EAAE;AAAA,UACb,YAAY,CAAC,EAAE,WAAW,EAAE,SAAS;AAAA,UACrC,UAAU;AAAA,UACV,UAAU;AAAA,UACV,KAAK,IAAI,QAAQ,sCAAsC,4BAA4B;AAAA,UACnF,QAAQ,CAAC;AAAA,UACT,8BAA8B,CAAC;AAAA,UAC/B,UAAU;AAAA,UACV,YAAY,EAAE;AAAA,UACd,OAAO,EAAE;AAAA,UACT,iBAAiB;AAAA,UACjB,uBAAuB;AAAA,UACvB,UAAU;AAAA,UACV,QAAQ;AAAA,UACR,eAAe;AAAA,UACf,sBAAsB;AAAA,UACtB,4BAA4B;AAAA,QAC9B;AACA,iBAAS,KAAK,OAAO;AAAA,MACvB;AACA,UAAI,CAAC,mBAAmB,qBAAqB,MAAM;AACjD,gBAAQ,6BAA6B,KAAK,CAAC,kBAAkB,EAAE,MAAM,CAAC;AACtE,2BAAmB;AAAA,MACrB;AACA,cAAQ,WAAY,QAAQ,YAAY;AACxC,cAAQ,kBAAmB,QAAQ,mBAAmB;AACtD,cAAQ,wBAAyB,QAAQ,yBAAyB;AAClE,cAAQ,QAAS,QAAQ,SAAS,EAAE;AACpC,cAAQ,WAAY,EAAE,SAAS,QAAQ,SAAU,EAAE;AACnD,cAAQ,WAAW,KAAK,IAAI,QAAQ,UAAU,OAAO,EAAE,eAAe,MAAM,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC;AAC5F,cAAQ,SAAS,QAAQ,OAAO,OAAO,EAAE,MAAM;AAC/C,cAAQ,WAAW,CAAC,EAAE,SAAS,EAAE,OAAO;AACxC,cAAQ,iBAAiB,EAAE;AAC3B,cAAQ,wBAAwB;AAChC,cAAQ,8BAA8B;AAAA,IACxC,CAAC;AAED,QAAI,SAAS;AACX,oBAAc,OAAO;AAAA,IACvB;AAEA,WAAO;AAAA,EACT;AAEA,iBAAsB,YAAY,UAAkB,OAAe,KAAa;AAC9E,QAAI,WAAW,MAAM,mBAAmB,OAAO,KAAK,QAAQ;AAC5D,eAAW,qBAAqB,OAAO,KAAK,QAAQ;AACpD,WAAO,qBAAqB,QAAQ,EAAE,QAAQ;AAAA,EAChD;;;ACpKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,MAAM,WAAgC,CAAC;AAEvC,iBAAe,UAAU,UAAkB,QAA8B,UAAU,OAAO;AACxF,QAAI,MAAM;AACV,QAAI,WAAW,QAAW;AACxB,aAAO,IAAI,IAAI,gBAAgB,MAAM;AAAA,IACvC;AAIA,QAAI,SAAS,GAAG,KAAK,CAAC,SAAS;AAC7B,aAAO,SAAS,GAAG;AAAA,IACrB;AAEA,aAAS,GAAG,IAAI,MAAM,gBAAQ,IAAI,GAAG;AAErC,eAAW,MAAM;AACf,aAAO,SAAS,GAAG;AAAA,IACrB,GAAG,MAAO,KAAK,EAAE;AAEjB,WAAO,SAAS,GAAG;AAAA,EACrB;AAEO,WAAS,cAAc,WAAmB,UAAU,OAAO,SAAS,QAAW;AACpF,WAAO,UAAU,YAAY,mBAAmB,QAAQ,OAAO;AAAA,EACjE;AAEO,WAAS,WAAW,WAAmB,QAAQ;AACpD,WAAO,UAAU,YAAY,sBAAsB,MAAM;AAAA,EAC3D;AAEO,WAAS,aAAa,UAAkB,MAAc,aAAsB;AACjF,WAAO,UAAU,QAAQ,wBAAwB,EAAE,MAAM,YAAY,CAAC;AAAA,EACxE;AAEA,iBAAsB,cAAc,UAAkB,OAAiB,aAAsB;AAC3F,WAAO,gBAAQ,KAAK,MAAM,yBAAyB,EAAE,OAAO,YAAY,CAAC;AAAA,EAC3E;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEO,WAAS,eAAe,UAAkB,UAAU,WAAW,YAAoB,eAAuB;AAC/G,WAAO,gBAAQ,KAAK,iBAAiB,4BAA4B;AAAA,MAC/D;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEO,WAAS,iBAAiB,UAAkB;AACjD,WAAO,gBAAQ,IAAI,iBAAiB,oBAAoB;AAAA,EAC1D;AAEO,WAAS,gBACd,UACA,UACA,WACA,YACA,eACA,WACA,OACA;AACA,WAAO,gBAAQ,IAAI,iBAAiB,sBAAsB;AAAA,MACxD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEO,WAAS,kBAAkB,UAAkB,eAAuB,UAAiC,OAAgB;AAC1H,WAAO,gBAAQ,MAAM,iBAAiB,sBAAsB;AAAA,MAC1D,IAAI;AAAA,MACJ,WAAW;AAAA,MACX;AAAA,IACF,CAAC;AAAA,EACH;AAEO,WAAS,mBAAmB,UAAkB,eAAuB;AAC1E,WAAO,gBAAQ,OAAO,iBAAiB,sBAAsB,EAAE,IAAI,cAAc,CAAC;AAAA,EACpF;AAEO,WAAS,iBAAiB,UAAkB;AACjD,WAAO,gBAAQ,IAAI,iBAAiB,eAAe;AAAA,EACrD;;;AChDA;AAAA;AAAA;AAAA;AAGA,MAAMC,WAAU,IAAI,cAAc,eAAO,aAAa;AAE/C,WAAS,oBAAoB,UAAkB,KAAa,KAAa;AAC9E,WAAO,GAAGA,SAAQ,mBAAmB,yBAAyB,IAAI,gBAAgB,EAAE,KAAK,IAAI,CAAC;AAAA,EAChG;","names":["configure","request","configure","request","segment","request"]}