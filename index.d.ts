/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** Type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/v1/me": {
    /**
     * User profile 
     * @description Returns information about the authenticated user
     */
    get: operations["getProfile"];
  };
  "/v1/me/devices": {
    /**
     * Device list 
     * @description List devices owned or readable by authenticated user
     */
    get: operations["getDevices"];
  };
  "/v1/{dongleId}/devices": {
    /**
     * User device list (admin) 
     * @description List devices owned or readable by specified user
     */
    get: operations["getUserDevices"];
    
  };
  "/v1.1/devices/{dongleId}": {
    /**
     * Device details 
     * @description Returns information about the specified device
     */
    get: operations["getDevice"];
    
  };
  "/v1/devices/{dongleId}": {
    /** Update device alias */
    patch: operations["updateDevice"];
    
  };
  "/v1/devices/{dongleId}/location": {
    /** Device location */
    get: operations["getDeviceLocation"];
    
  };
  "/v1/devices/{dongleId}/pair": {
    /**
     * Pair device 
     * @description Pair a device to a user's account.
     */
    post: operations["pairDeviceToUser"];
    
  };
  "/v1/devices/{dongleId}/unpair": {
    /**
     * Unpair device 
     * @description Unpair device from authenticated user's account. Any comma prime subscription linked to the device will be cancelled.
     */
    post: operations["unpairDevice"];
    
  };
  "/v1/devices/{dongleId}/owner": {
    /**
     * Device owner 
     * @description Returns the owner of a device.
     */
    get: operations["getDeviceOwner"];
    
  };
  "/v1/devices/{dongleId}/users": {
    /**
     * Device users 
     * @description List users with access to a device
     */
    get: operations["getDeviceUsers"];
    
  };
  "/v1/devices/{dongleId}/add_user": {
    /**
     * Grant device access 
     * @description Grant read permissions to a user by email. Authed user must be device owner to perform. If multiple users are attached to an email address, device access is granted to all users.
     */
    post: operations["addDeviceUser"];
    
  };
  "/v1/devices/{dongleId}/del_user": {
    /**
     * Revoke device access 
     * @description Revoke read permissions from a user by email. Authed user must be device owner to perform. If multiple users are attached to an email address, device access is removed from all users.
     */
    post: operations["revokeDeviceUser"];
    
  };
  "/v1.1/devices/{dongleId}/stats": {
    /**
     * Device driving statistics 
     * @description Returns aggregate driving statistics for a device over the past 7 days and all time.
     */
    get: operations["getDeviceStatistics"];
    
  };
  "/v1/devices/{dongleId}/bootlogs": {
    /**
     * Device boot logs 
     * @description Retrieve boot logs uploaded from a device.
     */
    get: operations["getDeviceBootLogs"];
    
  };
  "/v1/devices/{dongleId}/crashlogs": {
    /**
     * Device crash logs 
     * @description Retrieve crash logs uploaded from a device.
     */
    get: operations["getDeviceCrashLogs"];
    
  };
  "/v1/devices/{dongleId}/routes": {
    /**
     * Device routes 
     * @description Returns a list of routes uploaded from a device.
     */
    get: operations["getDeviceRoutes"];
    
  };
  "/v1/devices/{dongleId}/routes/preserved": {
    /**
     * Device preserved routes 
     * @description Returns a list of preserved routes uploaded from a device.
     */
    get: operations["getDevicePreservedRoutes"];
    
  };
  "/v1/devices/{dongleId}/routes_segments": {
    /**
     * Device routes segments 
     * @description Returns a list of route segments uploaded from a device between a start and end timestamp.
     */
    get: operations["getDeviceRoutesSegments"];
    
  };
  "/v1/devices/{dongleId}/segments": {
    /**
     * Device segments 
     * @description Returns time-sorted list of segments, each of which includes basic metadata derived from openpilot logs.
     */
    get: operations["getDeviceSegments"];
    
  };
  "/v1/devices/{dongleId}/athena_offline_queue": {
    /**
     * Athena offline queue 
     * @description Return a list of queued payloads for delivery to device when it is online.
     */
    get: operations["getDeviceAthenaOfflineQueue"];
    
  };
  "/v1.4/{dongleId}/upload_url": {
    /**
     * Log file upload 
     * @description Request a URL to which an openpilot file an be uploaded via HTTP PUT. This endpoint only accepts tokens signed with a device private key.
     */
    get: operations["getUploadUrl"];
    
  };
  "/v1/{dongleId}/upload_urls": {
    /**
     * Batch log file upload 
     * @description Request URLs to which openpilot files can be uploaded via HTTP PUT. This endpoint only accepts tokens signed with a device private key.
     */
    post: operations["getUploadUrls"];
    
  };
  "/v2/pilotpair": {
    /**
     * Pair device 
     * @description Pair a device to the authenticated user's account.
     */
    post: operations["pilotPair"];
  };
  "/v2/pilotauth": {
    /** Authenticate device (openpilot) */
    post: operations["pilotAuth"];
  };
  "/v1/route/{routeName}": {
    /**
     * Route details 
     * @description Returns information about the specified route. Authenticated user must have ownership of, or read access to, the device from which the route was uploaded.
     */
    get: operations["getRoute"];
    
  };
  "/v1/route/{routeName}/segments": {
    /**
     * Route segments 
     * @description Returns list of segments comprising a route. Authenticated user must have ownership of, or read access to, the device from which the route was uploaded.
     */
    get: operations["getRouteSegments"];
    
  };
  "/v1/route/{routeName}/files": {
    /**
     * Raw log files 
     * @description Retrieve uploaded files for a route. Calls to this API are rate limited to 5 per minute.
     */
    get: operations["getRouteFiles"];
    
  };
  "/v1/route/{routeName}/qcamera.m3u8": {
    /**
     * Route HLS stream 
     * @description Returns rear camera HLS stream index of MPEG-TS fragments.
     */
    get: operations["getRouteStream"];
    
  };
  "/v1/route/{routeName}/share_signature": {
    /**
     * Route sharing signature 
     * @description Return route share URL signature. Expires in 365 days.
     */
    get: operations["getRouteShareSignature"];
    
  };
  "/v1/route/{routeName}/preserve": {
    /**
     * Preserve route 
     * @description Preserve route from deletion. Authenticated user must have ownership of the device from which the route was uploaded.
     */
    post: operations["preserveRoute"];
    /**
     * Unpreserve route 
     * @description Unpreserve route from deletion. Authenticated user must have ownership of the device from which the route was uploaded.
     */
    delete: operations["unpreserveRoute"];
    
  };
  "/v1/tokens/mapbox/{dongleId}": {
    /**
     * Mapbox token 
     * @description Returns a Mapbox token for the specified dongle ID. Authenticated user must have ownership of the dongle ID.
     */
    get: operations["getMapboxToken"];
    
  };
  "/v1/navigation/{dongleId}/set_destination": {
    /**
     * Set nav destination 
     * @description Set destination for navigation. Authenticated user must have ownership of the dongle ID.
     */
    post: operations["setDestination"];
    
  };
  "/v1/navigation/{dongleId}/next": {
    /**
     * Get nav destination 
     * @description Retrieve next location from database. This was set on Set destination if the device was offline. Next location is removed from the database after this call or when a new destination is set.
     */
    get: operations["getNavigationNext"];
    /**
     * Clear nav destination 
     * @description Delete next destination from database.
     */
    delete: operations["clearNavigationNext"];
    
  };
  "/v1/navigation/{dongleId}/locations": {
    /**
     * Saved locations 
     * @description Retrieve saved locations from database.
     */
    get: operations["getNavigationSavedLocations"];
    /** Save location */
    put: operations["saveNavigationLocation"];
    /** Delete location */
    delete: operations["deleteNavigationLocation"];
    /** Update location */
    patch: operations["updateNavigationLocation"];
    
  };
  "/v1/clips/create": {
    /**
     * Create clip 
     * @description Create a clip from a route.
     */
    post: operations["createClip"];
  };
  "/v1/clips/list": {
    /**
     * List clips 
     * @description List clips created for the specified device.
     */
    get: operations["getClips"];
  };
  "/v1/clips/details": {
    /** Get clip details */
    get: operations["getClip"];
  };
  "/v1/clips/update": {
    /** Delete clip */
    delete: operations["deleteClip"];
    /** Update clip */
    patch: operations["updateClip"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Profile: {
      /**
       * Format: email 
       * @description Email address 
       * @example commaphone3@gmail.com
       */
      email: string;
      /**
       * @description Dongle ID 
       * @example 2e9eeac96ea4e6a6
       */
      id: string;
      /**
       * @deprecated 
       * @description comma points 
       * @example 34933
       */
      points: number;
      /**
       * @description Unix timestamp at time of registration 
       * @example 1465103707
       */
      regdate: number;
      /**
       * @description <a href="https://comma.ai/jobs">Apply for superuser here</a> 
       * @example false
       */
      superuser: boolean;
      /**
       * @deprecated 
       * @description Username 
       * @example joeyjoejoe
       */
      username?: string | null;
      /**
       * @description OAuth2 user ID 
       * @example google_111803823964622526972
       */
      user_id: string;
    };
    Device: {
      dongle_id: components["schemas"]["DongleID"];
      /** @description Device nickname */
      alias: string;
      /** @description Device serial number */
      serial: string;
      /** @description Last connected athena server hostname */
      athena_host?: string | null;
      /** @description Unix timestamp of last athena ping */
      last_athena_ping?: number;
      /** @description Uploads are ignored from this device */
      ignore_uploads?: boolean | null;
      /** @description Device has an owner */
      is_paired: boolean;
      /** @description Authenticated user has write-access to the device */
      is_owner?: boolean;
      /** @description 2048-bit public RSA key */
      public_key: string | null;
      /** @description Device has a prime subscription */
      prime: boolean;
      /**
       * @description Prime subscription type
       * - 0 = None
       * - 1 = Magenta
       * - 2 = Lite
       * - 3 = Blue
       * - 4 = Magenta New
       *  
       * @enum {number}
       */
      prime_type: 0 | 1 | 2 | 3 | 4;
      /** @description Device prime trial is claimed */
      trial_claimed: boolean | null;
      /**
       * @description Device type 
       * @enum {string}
       */
      device_type: "app" | "neo" | "panda" | "two" | "freon" | "pc" | "three";
      last_gps_time: number | null;
      last_gps_lat: number | null;
      last_gps_lng: number | null;
      last_gps_accuracy: number | null;
      last_gps_speed: number | null;
      last_gps_bearing: number | null;
      openpilot_version?: string | null;
      sim_id: string | null;
    };
    DeviceUser: {
      /** @description User email */
      email: string;
      permission: components["schemas"]["DeviceUserPermission"];
    };
    /**
     * @description Device user permission 
     * @enum {string}
     */
    DeviceUserPermission: "read_access" | "owner";
    DeviceLocation: {
      /** @description Latitude, in decimal degrees */
      lat: number;
      /** @description Longitude, in decimal degrees */
      lng: number;
      /** @description Unix timestamp, in milliseconds */
      time: number;
      /** @description Accuracy, in metres */
      accuracy: number;
      /** @description Speed, in metres per second */
      speed: number;
      /** @description Bearing angle, in degrees from north */
      bearing: number;
    };
    /** @description Summary of drives over a period of time */
    DrivingStatistics: {
      /** @description Sum of distance driven in time period, in miles */
      distance: number;
      /** @description Sum of time driven in time period, in minutes */
      minutes: number;
      /** @description Count of routes in time period */
      routes: number;
    };
    /** @description A single segment of a route is up to 60 seconds in length. */
    Segment: {
      canonical_name: components["schemas"]["SegmentName"];
      /** @description Segment number */
      number: number;
      canonical_route_name: components["schemas"]["RouteName"];
      dongle_id: components["schemas"]["DongleID"];
      /** @description Unix timestamp at which upload_url was first called for file in segment */
      create_time: number;
      /** @description Milliseconds since epoch of segment start time */
      start_time_utc_millis: number;
      /** @description Milliseconds since epoch of segment end time */
      end_time_utc_millis: number;
      /** @description Signed URL from which route.coords and JPEGs can be downloaded */
      url: string;
      /** @description Sum of distances between GPS points in miles */
      length: number;
      /** @description Segment contains CAN messages */
      can: boolean;
      /** @description Segment has ublox packets */
      hpgps: boolean;
      /** @description Segment contains radar tracks in CAN */
      radar: boolean;
      devicetype: components["schemas"]["SegmentDataSource"];
      proc_log: components["schemas"]["FileProcStatus"];
      proc_qlog: components["schemas"]["FileProcStatus"];
      proc_camera: components["schemas"]["FileProcStatus"];
      proc_dcamera: components["schemas"]["FileProcStatus"];
      passive: boolean;
      version: string;
      git_commit: string;
      git_branch: string;
      git_remote: string;
      git_dirty: boolean;
    };
    Route: {
      fullname: components["schemas"]["RouteName"];
      dongle_id: components["schemas"]["DongleID"];
      user_id: components["schemas"]["DongleID"];
      is_public?: boolean;
      /** @description Unix timestamp at which upload_url was first called for file in route */
      create_time: number;
      /** @description Signed storage bucket URL from which route.coords and JPEGs can be downloaded */
      url: string;
      /** @description Unix timestamp at which signed URL expires */
      share_expiry: number;
      /** @description URL signature */
      share_sig: string;
      /** @description Sum of distances between GPS points in miles */
      length: number;
      /** @description Route contains CAN messages */
      can?: boolean;
      /** @description Route has ublox packets */
      hpgps?: boolean;
      /** @description Route contains radar tracks in CAN */
      radar?: boolean;
      devicetype: components["schemas"]["SegmentDataSource"];
      /** @description Maximum qlog segment number uploaded */
      maxqlog?: number;
      /** @description Maximum qcamera segment number uploaded */
      maxqcamera?: number;
      /** @description Maximum log segment number uploaded */
      maxlog: number;
      /** @description Maximum road camera segment number uploaded */
      maxcamera: number;
      /** @description Maximum driver camera segment number uploaded */
      maxdcamera: number;
      /** @description Maximum wide road camera segment number uploaded */
      maxecamera?: number;
      /** @description Maximum qlog segment number processed */
      procqlog?: number;
      /** @description Maximum qcamera segment number processed */
      procqcamera?: number;
      /** @description Maximum log segment number processed */
      proclog: number;
      /** @description Maximum road camera segment number processed */
      proccamera: number;
      /** @description First latitude recorded in route from GPS */
      start_lat?: number;
      /** @description First longitude recorded in route from GPS */
      start_lng?: number;
      /** @description Unix timestamp at beginning of route */
      start_time: number;
      /** @description Last latitude recorded in route from GPS */
      end_lat?: number;
      /** @description Last longitude recorded in route from GPS */
      end_lng?: number;
      /** @description Unix timestamp at end of last segment in route */
      end_time: number;
      passive?: boolean;
      version?: string;
      git_commit?: string;
      git_branch?: string;
      git_remote?: string;
      git_dirty?: boolean;
      platform?: string;
      vin?: components["schemas"]["VIN"];
      /** @description Minimum logMonoTime from openpilot log */
      init_logmonotime?: number;
    };
    RouteSegment: components["schemas"]["Route"] & {
      /** @description Segment numbers in route */
      segment_numbers: (number)[];
      /** @description Segment start times in milliseconds since epoch */
      segment_start_times: (number)[];
      /** @description Segment end times in milliseconds since epoch */
      segment_end_times: (number)[];
    };
    /**
     * @description Device type 
     * @enum {string}
     */
    DeviceType: "app" | "neo" | "panda" | "two" | "freon" | "pc" | "three";
    /**
     * @description Data source
     * - 3 = eon
     * - 6 = comma two
     * - 7 = comma three
     *  
     * @enum {integer}
     */
    SegmentDataSource: 3 | 6 | 7;
    /**
     * @description Log file status
     * -1 = Not received
     * 0 = Upload URL sent
     * 10 = Received
     * 20 = Enqueued
     * 30 = Processing
     * 40 = Processed
     * 50 = Errored
     *  
     * @enum {integer}
     */
    FileProcStatus: -1 | 0 | 10 | 20 | 30 | 40 | 50;
    /**
     * @description File type
     * 1. Road camera (camera)
     * 2. Front camera (driver, dcamera)
     * 3. Log (raw, rlog)
     * 4. Qlog
     * 5. QCamera
     * 6. Wide road camera (extended, ecamera)
     *  
     * @enum {integer}
     */
    FileType: 1 | 2 | 3 | 4 | 5 | 6;
    /**
     * Dongle ID 
     * @description A unique 16-character hexadecimal string. Can represent a device or a user. 
     * @example 1a2b3c4d5e6f7a8b
     */
    readonly DongleID: string;
    /**
     * Canonical route name 
     * @description Contains a dongle ID and timestamp of the beginning of the route 
     * @example 1a2b3c4d5e6f7a8b|2019-01-01--00-00-00
     */
    RouteName: string;
    /**
     * Canonical segment name 
     * @description Contains a dongle ID, timestamp of the beginning of the route, and segment number 
     * @example 1a2b3c4d5e6f7a8b|2019-01-01--00-00-00--0
     */
    SegmentName: string;
    /**
     * Vehicle identification number 
     * @description 17-character alphanumeric string 
     * @example 5YJ3E1EA7HF000000
     */
    VIN: string;
    /** Navigation destination */
    NavigationDestination: {
      /**
       * @description Short name of destination 
       * @example 1441 State St
       */
      place_name: string;
      /**
       * @description Address details of destination. Should not include short name. 
       * @example San Diego, CA 92101, United States
       */
      place_details: string;
      /**
       * @description Latitude, decimal degrees 
       * @example 32.72045
       */
      latitude: number;
      /**
       * @description Longitude, decimal degrees 
       * @example -117.16621
       */
      longitude: number;
    };
    /**
     * Navigation saved location ID 
     * @description Identifier for a saved location
     */
    readonly NavigationSavedLocationID: number;
    /** Navigation saved location */
    NavigationSavedLocation: ({
      id: components["schemas"]["NavigationSavedLocationID"];
      dongle_id: components["schemas"]["DongleID"];
      save_type: components["schemas"]["NavigationLocationType"];
      /** @description Optional label for locations with type "favorite" */
      label?: string | null;
      /** @description When this saved location was last modified */
      modified: string;
    }) & components["schemas"]["NavigationDestination"];
    /**
     * @description Navigation location type 
     * @enum {string}
     */
    NavigationLocationType: "favorite" | "recent";
    /**
     * Clip ID 
     * @description Unique identifier for a clip
     */
    readonly ClipID: number;
    /**
     * Clip 
     * @description Video clip created from a route
     */
    Clip: {
      id: components["schemas"]["ClipID"];
      create_time: number;
      dongle_id: components["schemas"]["DongleID"];
      route_name: components["schemas"]["RouteName"];
      start_time: number;
      end_time: number;
      video_type: components["schemas"]["ClipVideoType"];
      /** @description Clip status */
      status: "pending" | "done" | "failed";
      /** @description Clip is publicly accessible */
      is_public: boolean;
      /** @description Optional title for clip */
      title?: string | null;
    };
    /** @description Clip video type */
    ClipVideoType: "q" | "f" | "e" | "d" | "360";
    /** Pending Clip */
    PendingClip: components["schemas"]["Clip"] & {
      /** @constant */
      status?: "pending";
      /** @description Pending clip status */
      pending_status?: string;
      /** @description Pending clip progress */
      pending_progress?: string;
    };
    /** Done Clip */
    DoneClip: components["schemas"]["Clip"] & {
      /** @constant */
      status?: "done";
      /** @description URL to clip */
      url?: string;
      /** @description URL to clip thumbnail */
      thumbnail?: string;
    };
    /** Failed Clip */
    FailedClip: components["schemas"]["Clip"] & {
      /** @constant */
      status?: "failed";
      /** @description Error message */
      error_status?: string;
    };
    /** Clip Details */
    ClipDetails: components["schemas"]["PendingClip"] | components["schemas"]["DoneClip"] | components["schemas"]["FailedClip"];
  };
  responses: {
    /** @description Operation successful */
    SuccessInteger: {
      content: {
        "application/json": {
          /** @constant */
          success: 1;
        };
      };
    };
    /** @description Operation successful */
    SuccessBoolean: {
      content: {
        "application/json": {
          /** @constant */
          success: true;
        };
      };
    };
  };
  parameters: {
    /** @description Dongle ID */
    dongleId: components["schemas"]["DongleID"];
    /** @description Canonical route name */
    routeName: components["schemas"]["RouteName"];
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  getProfile: {
    /**
     * User profile 
     * @description Returns information about the authenticated user
     */
    responses: {
      /** @description JSON object containing the user's profile information */
      200: {
        content: {
          "application/json": components["schemas"]["Profile"];
        };
      };
    };
  };
  getDevices: {
    /**
     * Device list 
     * @description List devices owned or readable by authenticated user
     */
    responses: {
      /** @description JSON array of device objects */
      200: {
        content: {
          "application/json": (components["schemas"]["Device"])[];
        };
      };
    };
  };
  getUserDevices: {
    /**
     * User device list (admin) 
     * @description List devices owned or readable by specified user
     */
    responses: {
      /** @description JSON array of device objects */
      200: {
        content: {
          "application/json": (components["schemas"]["Device"])[];
        };
      };
    };
  };
  getDevice: {
    /**
     * Device details 
     * @description Returns information about the specified device
     */
    responses: {
      /** @description JSON object containing the device's information */
      200: {
        content: {
          "application/json": components["schemas"]["Device"];
        };
      };
    };
  };
  updateDevice: {
    /** Update device alias */
    requestBody?: {
      content: {
        "application/json": {
          alias: string;
        };
      };
    };
    responses: {
      /** @description JSON object containing the updated device's information */
      200: {
        content: {
          "application/json": components["schemas"]["Device"];
        };
      };
    };
  };
  getDeviceLocation: {
    /** Device location */
    responses: {
      /** @description JSON object containing device location, or an error message if the location is not known. */
      200: {
        content: {
          "application/json": OneOf<[components["schemas"]["DeviceLocation"] & {
            dongle_id: components["schemas"]["DongleID"];
          }, {
            error: "Location unavailable";
          }]>;
        };
      };
    };
  };
  pairDeviceToUser: {
    /**
     * Pair device 
     * @description Pair a device to a user's account.
     */
    requestBody?: {
      content: {
        "application/json": {
          user_id?: components["schemas"]["DongleID"];
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessInteger"];
    };
  };
  unpairDevice: {
    /**
     * Unpair device 
     * @description Unpair device from authenticated user's account. Any comma prime subscription linked to the device will be cancelled.
     */
    responses: {
      200: components["responses"]["SuccessInteger"];
    };
  };
  getDeviceOwner: {
    /**
     * Device owner 
     * @description Returns the owner of a device.
     */
    responses: {
      /** @description JSON object containing information about the device owner */
      200: {
        content: {
          "application/json": {
            /** @description OAuth2 user ID */
            user_id?: string;
            /** @description comma points */
            points?: number;
            /** @deprecated */
            username?: string | null;
            email?: string;
          };
        };
      };
    };
  };
  getDeviceUsers: {
    /**
     * Device users 
     * @description List users with access to a device
     */
    responses: {
      /** @description JSON array of device user objects */
      200: {
        content: {
          "application/json": (components["schemas"]["DeviceUser"])[];
        };
      };
    };
  };
  addDeviceUser: {
    /**
     * Grant device access 
     * @description Grant read permissions to a user by email. Authed user must be device owner to perform. If multiple users are attached to an email address, device access is granted to all users.
     */
    requestBody?: {
      content: {
        "application/json": {
          /** @description Email of user to add */
          email?: string;
          /** @description OAuth2 user ID of user to add */
          email_userid?: string;
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessInteger"];
    };
  };
  revokeDeviceUser: {
    /**
     * Revoke device access 
     * @description Revoke read permissions from a user by email. Authed user must be device owner to perform. If multiple users are attached to an email address, device access is removed from all users.
     */
    requestBody?: {
      content: {
        "application/json": {
          email: string;
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessInteger"];
    };
  };
  getDeviceStatistics: {
    /**
     * Device driving statistics 
     * @description Returns aggregate driving statistics for a device over the past 7 days and all time.
     */
    responses: {
      /** @description JSON object containing driving statistics */
      200: {
        content: {
          "application/json": {
            all?: components["schemas"]["DrivingStatistics"];
            week?: components["schemas"]["DrivingStatistics"];
          };
        };
      };
    };
  };
  getDeviceBootLogs: {
    /**
     * Device boot logs 
     * @description Retrieve boot logs uploaded from a device.
     */
    responses: {
      /** @description JSON array of URLs to boot log files. Files are available at each URL for one hour from the time of the request. */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
    };
  };
  getDeviceCrashLogs: {
    /**
     * Device crash logs 
     * @description Retrieve crash logs uploaded from a device.
     */
    responses: {
      /** @description JSON array of URLs to crash log files. Files are available at each URL for one hour from the time of the request. */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
    };
  };
  getDeviceRoutes: {
    /**
     * Device routes 
     * @description Returns a list of routes uploaded from a device.
     */
    parameters?: {
        /** @description Maximum number of routes to return */
        /** @description Return routes created after this timestamp */
      query?: {
        limit?: number;
        created_after?: number;
      };
    };
    responses: {
      /** @description JSON array of route objects */
      200: {
        content: {
          "application/json": (components["schemas"]["Route"])[];
        };
      };
    };
  };
  getDevicePreservedRoutes: {
    /**
     * Device preserved routes 
     * @description Returns a list of preserved routes uploaded from a device.
     */
    responses: {
      /** @description JSON array of route objects */
      200: {
        content: {
          "application/json": (components["schemas"]["Route"])[];
        };
      };
    };
  };
  getDeviceRoutesSegments: {
    /**
     * Device routes segments 
     * @description Returns a list of route segments uploaded from a device between a start and end timestamp.
     */
    parameters?: {
        /** @description Start timestamp in milliseconds */
        /** @description End timestamp in milliseconds */
      query?: {
        start?: number;
        end?: number;
      };
    };
    responses: {
      /** @description JSON array of route segment objects */
      200: {
        content: {
          "application/json": (components["schemas"]["RouteSegment"])[];
        };
      };
    };
  };
  getDeviceSegments: {
    /**
     * Device segments 
     * @description Returns time-sorted list of segments, each of which includes basic metadata derived from openpilot logs.
     */
    parameters: {
        /** @description Start timestamp in milliseconds */
        /** @description End timestamp in milliseconds */
      query: {
        from: number;
        to: number;
      };
    };
    responses: {
      /** @description JSON array of segments */
      200: {
        content: {
          "application/json": (components["schemas"]["Segment"])[];
        };
      };
    };
  };
  getDeviceAthenaOfflineQueue: {
    /**
     * Athena offline queue 
     * @description Return a list of queued payloads for delivery to device when it is online.
     */
    responses: {
      /** @description JSON array of queued payloads */
      200: {
        content: {
          "application/json": ({
              expiry?: number;
              [key: string]: unknown | undefined;
            })[];
        };
      };
    };
  };
  getUploadUrl: {
    /**
     * Log file upload 
     * @description Request a URL to which an openpilot file an be uploaded via HTTP PUT. This endpoint only accepts tokens signed with a device private key.
     */
    parameters: {
        /** @description File to upload from openpilot data directory. */
        /** @description Number of days the url should be valid. */
      query: {
        path: string;
        expiry_days?: number;
      };
    };
    responses: {
      /** @description JSON object containing upload URL */
      200: {
        content: {
          "application/json": {
            /** @description URL to which a PUT request can be sent with file contents */
            url?: string;
          };
        };
      };
    };
  };
  getUploadUrls: {
    /**
     * Batch log file upload 
     * @description Request URLs to which openpilot files can be uploaded via HTTP PUT. This endpoint only accepts tokens signed with a device private key.
     */
    requestBody?: {
      content: {
        /**
         * @example {
         *   "paths": [
         *     "2019-06-06--11-30-31--9/fcamera.hevc",
         *     "2019-06-06--11-30-31--9/ecamera.hevc"
         *   ],
         *   "expiry_days": 1
         * }
         */
        "application/json": {
          /** @description Files to upload from openpilot data directory. */
          paths: (string)[];
          /**
           * @description number of days the url should be valid 
           * @default 1
           */
          expiry_days?: number;
        };
      };
    };
    responses: {
      /** @description JSON array containing upload URLs */
      200: {
        content: {
          "application/json": ({
              /** @description URL to which a PUT request can be sent with file contents */
              url?: string;
            })[];
        };
      };
    };
  };
  pilotPair: {
    /**
     * Pair device 
     * @description Pair a device to the authenticated user's account.
     */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description JWT signed by your device private key. Payload contains `{"identity": <dongle-id>, "pair": true}` */
          pair_token: string;
        };
      };
    };
    responses: {
      /** @description JSON object containing pairing result */
      200: {
        content: {
          "application/json": {
            /** @description True if the device was unpaired prior to this call. False if the device was previously paired by an authenticated user. */
            first_pair?: boolean;
          };
        };
      };
    };
  };
  pilotAuth: {
    /** Authenticate device (openpilot) */
    requestBody?: {
      content: {
        "application/json": {
          /** @description Device IMEI */
          imei: string;
          /** @description Device IMEI, second slot */
          imei2?: string;
          /** @description Device serial number */
          serial: string;
          /** @description 2048-bit RSA public key */
          public_key: string;
          /** @description JWT signed by private key. Payload must contain {"register": true} */
          register_token: string;
        };
      };
    };
    responses: {
      /** @description JSON object containing authenticated dongle ID and token */
      200: {
        content: {
          "application/json": {
            dongle_id: components["schemas"]["DongleID"];
            /** @description JWT */
            access_token: string;
          };
        };
      };
    };
  };
  getRoute: {
    /**
     * Route details 
     * @description Returns information about the specified route. Authenticated user must have ownership of, or read access to, the device from which the route was uploaded.
     */
    responses: {
      /** @description JSON object containing route information */
      200: {
        content: {
          "application/json": components["schemas"]["Route"];
        };
      };
    };
  };
  getRouteSegments: {
    /**
     * Route segments 
     * @description Returns list of segments comprising a route. Authenticated user must have ownership of, or read access to, the device from which the route was uploaded.
     */
    responses: {
      /** @description JSON array of segments */
      200: {
        content: {
          "application/json": (components["schemas"]["Segment"])[];
        };
      };
    };
  };
  getRouteFiles: {
    /**
     * Raw log files 
     * @description Retrieve uploaded files for a route. Calls to this API are rate limited to 5 per minute.
     */
    responses: {
      /** @description JSON object containing signed URLs to various log files. URLs are valid for 1 hour. All arrays are sorted by segment number ascending. */
      200: {
        content: {
          "application/json": {
            /** @description Array of signed URLs to qlog.bz2 files */
            qlogs: (string)[];
            /** @description Array of signed URLs to qcamera.ts files */
            qcameras: (string)[];
            /** @description Array of signed URLs to rlog.bz2 files */
            logs: (string)[];
            /** @description Array of signed URLs to fcamera.hevc files */
            cameras: (string)[];
            /** @description Array of signed URLs to dcamera.hevc files */
            dcameras: (string)[];
            /** @description Array of signed URLs to ecamera.hevc files */
            ecameras: (string)[];
          };
        };
      };
    };
  };
  getRouteStream: {
    /**
     * Route HLS stream 
     * @description Returns rear camera HLS stream index of MPEG-TS fragments.
     */
    responses: {
      /** @description m3u8 playlist */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
    };
  };
  getRouteShareSignature: {
    /**
     * Route sharing signature 
     * @description Return route share URL signature. Expires in 365 days.
     */
    responses: {
      /** @description JSON object containing route share signature */
      200: {
        content: {
          "application/json": {
            /** @description Unix timestamp of expiration */
            exp: string;
            /** @description Signature */
            sig: string;
          };
        };
      };
    };
  };
  preserveRoute: {
    /**
     * Preserve route 
     * @description Preserve route from deletion. Authenticated user must have ownership of the device from which the route was uploaded.
     */
    responses: {
      200: components["responses"]["SuccessInteger"];
    };
  };
  unpreserveRoute: {
    /**
     * Unpreserve route 
     * @description Unpreserve route from deletion. Authenticated user must have ownership of the device from which the route was uploaded.
     */
    responses: {
      200: components["responses"]["SuccessInteger"];
    };
  };
  getMapboxToken: {
    /**
     * Mapbox token 
     * @description Returns a Mapbox token for the specified dongle ID. Authenticated user must have ownership of the dongle ID.
     */
    responses: {
      /** @description JSON object containing Mapbox token */
      200: {
        content: {
          "application/json": {
            /** @description Mapbox token */
            token?: string;
          };
        };
      };
    };
  };
  setDestination: {
    /**
     * Set nav destination 
     * @description Set destination for navigation. Authenticated user must have ownership of the dongle ID.
     */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["NavigationDestination"];
      };
    };
    responses: {
      /** @description Destination set */
      200: {
        content: {
          "application/json": {
            /** @constant */
            success?: true;
            /** @description True if the destination was stored and will be applied when the device is next online. False if the destination was set immediately. */
            saved_next?: boolean;
          };
        };
      };
    };
  };
  getNavigationNext: {
    /**
     * Get nav destination 
     * @description Retrieve next location from database. This was set on Set destination if the device was offline. Next location is removed from the database after this call or when a new destination is set.
     */
    responses: {
      /** @description JSON object containing next destination, or null if no destination is set */
      200: {
        content: {
          "application/json": components["schemas"]["NavigationDestination"];
        };
      };
    };
  };
  clearNavigationNext: {
    /**
     * Clear nav destination 
     * @description Delete next destination from database.
     */
    responses: {
      /** @description Destination cleared */
      200: {
        content: {
          "application/json": {
            /** @constant */
            success?: true;
            deleted?: components["schemas"]["NavigationDestination"];
          };
        };
      };
    };
  };
  getNavigationSavedLocations: {
    /**
     * Saved locations 
     * @description Retrieve saved locations from database.
     */
    responses: {
      /** @description JSON object containing saved locations */
      200: {
        content: {
          "application/json": (components["schemas"]["NavigationSavedLocation"])[];
        };
      };
    };
  };
  saveNavigationLocation: {
    /** Save location */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["NavigationSavedLocation"];
      };
    };
    responses: {
      200: components["responses"]["SuccessBoolean"];
    };
  };
  deleteNavigationLocation: {
    /** Delete location */
    requestBody?: {
      content: {
        "application/json": {
          id?: components["schemas"]["NavigationSavedLocationID"];
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessBoolean"];
    };
  };
  updateNavigationLocation: {
    /** Update location */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["NavigationSavedLocation"] & {
          id?: components["schemas"]["NavigationSavedLocationID"];
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessBoolean"];
    };
  };
  createClip: {
    /**
     * Create clip 
     * @description Create a clip from a route.
     */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["Clip"];
      };
    };
    responses: {
      /** @description JSON object containing clip ID, or an error message */
      200: {
        content: {
          "application/json": OneOf<[{
            /** @constant */
            success?: true;
            clip_id?: components["schemas"]["ClipID"];
          }, {
            /** @description Error code */
            error?: "too_many_pending";
          }]>;
        };
      };
    };
  };
  getClips: {
    /**
     * List clips 
     * @description List clips created for the specified device.
     */
    requestBody?: {
      content: {
        "application/json": {
          dongle_id?: components["schemas"]["DongleID"];
        };
      };
    };
    responses: {
      /** @description JSON array of clip objects */
      200: {
        content: {
          "application/json": components["schemas"]["ClipDetails"];
        };
      };
    };
  };
  getClip: {
    /** Get clip details */
    requestBody?: {
      content: {
        "application/json": {
          clip_id?: components["schemas"]["ClipID"];
          dongle_id?: components["schemas"]["DongleID"];
        };
      };
    };
    responses: {
      /** @description JSON object containing clip details */
      200: {
        content: {
          "application/json": components["schemas"]["ClipDetails"];
        };
      };
    };
  };
  deleteClip: {
    /** Delete clip */
    requestBody?: {
      content: {
        "application/json": {
          clip_id: components["schemas"]["ClipID"];
          dongle_id: components["schemas"]["DongleID"];
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessBoolean"];
    };
  };
  updateClip: {
    /** Update clip */
    requestBody?: {
      content: {
        "application/json": {
          clip_id: components["schemas"]["ClipID"];
          dongle_id: components["schemas"]["DongleID"];
          /** @description Whether the clip is public or not */
          is_public: boolean;
        };
      };
    };
    responses: {
      200: components["responses"]["SuccessBoolean"];
    };
  };
}
